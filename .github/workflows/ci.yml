name: CI

on:
  push:
    branches: ['**']
  pull_request:

jobs:
  verify:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        node-version: [20, 22]

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.29.3

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: pnpm
          cache-dependency-path: pnpm-lock.yaml

      - name: Install
        run: pnpm install --frozen-lockfile

      - name: Lint
        run: pnpm run lint

      - name: Test
        run: pnpm run test

      - name: Build
        run: pnpm run build

  docker-http-smoke:
    runs-on: ubuntu-latest
    needs: verify

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build Docker image
        run: docker build -t dynamic-mcp:test .

      - name: Run HTTP container
        run: |
          docker run -d --name dynamic-mcp-http \
            -p 8788:8788 \
            -e MCP_TRANSPORT=http \
            -e MCP_HOST=0.0.0.0 \
            -e MCP_PORT=8788 \
            dynamic-mcp:test

      - name: Wait for readiness
        run: |
          for i in $(seq 1 30); do
            if curl -fsS http://127.0.0.1:8788/readyz >/dev/null; then
              exit 0
            fi
            sleep 2
          done
          echo "Container did not become ready in time."
          docker logs dynamic-mcp-http
          exit 1

      - name: Probe liveness and readiness
        run: |
          curl -fsS http://127.0.0.1:8788/livez
          curl -fsS http://127.0.0.1:8788/readyz

      - name: Cleanup
        if: always()
        run: docker rm -f dynamic-mcp-http || true

  docker-http-jwt-smoke:
    runs-on: ubuntu-latest
    needs: verify

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build Docker image
        run: docker build -t dynamic-mcp:test .

      - name: Prepare CI JWKS and JWT
        run: |
          mkdir -p .tmp/ci-jwt
          node - <<'JS'
          const fs = require('node:fs');
          const path = require('node:path');
          const crypto = require('node:crypto');

          const outputDir = path.join('.tmp', 'ci-jwt');

          const { publicKey, privateKey } = crypto.generateKeyPairSync('rsa', {
            modulusLength: 2048
          });
          const publicJwk = publicKey.export({ format: 'jwk' });
          const kid = 'ci-rs256-key';
          const now = Math.floor(Date.now() / 1000);

          function b64url(input) {
            return Buffer.from(input)
              .toString('base64')
              .replace(/=/g, '')
              .replace(/\+/g, '-')
              .replace(/\//g, '_');
          }

          const header = {
            alg: 'RS256',
            typ: 'JWT',
            kid
          };
          const payload = {
            iss: 'https://ci-issuer.example.com/',
            aud: 'dynamic-mcp',
            sub: 'ci-workflow',
            scope: 'mcp.invoke',
            iat: now,
            exp: now + 600
          };

          const encodedHeader = b64url(JSON.stringify(header));
          const encodedPayload = b64url(JSON.stringify(payload));
          const signingInput = `${encodedHeader}.${encodedPayload}`;
          const signature = crypto.sign('RSA-SHA256', Buffer.from(signingInput), privateKey);
          const token = `${signingInput}.${b64url(signature)}`;

          const jwks = {
            keys: [
              {
                kty: 'RSA',
                kid,
                use: 'sig',
                alg: 'RS256',
                n: publicJwk.n,
                e: publicJwk.e
              }
            ]
          };

          fs.writeFileSync(path.join(outputDir, 'jwks.json'), JSON.stringify(jwks), 'utf8');
          fs.writeFileSync(path.join(outputDir, 'token.txt'), token, 'utf8');
          JS
          echo "JWT_TOKEN=$(cat .tmp/ci-jwt/token.txt)" >> "$GITHUB_ENV"

      - name: Start JWKS server
        run: |
          docker network create dynamic-mcp-ci
          docker run -d --name dynamic-mcp-jwks \
            --network dynamic-mcp-ci \
            -v "$PWD/.tmp/ci-jwt:/usr/share/nginx/html:ro" \
            nginx:alpine

      - name: Run HTTP container with JWT enabled
        run: |
          docker run -d --name dynamic-mcp-http-jwt \
            --network dynamic-mcp-ci \
            -p 8788:8788 \
            -e MCP_TRANSPORT=http \
            -e MCP_HOST=0.0.0.0 \
            -e MCP_PORT=8788 \
            -e MCP_AUTH_MODE=jwt \
            -e MCP_AUTH_JWKS_URL=http://dynamic-mcp-jwks/jwks.json \
            -e MCP_AUTH_ISSUER=https://ci-issuer.example.com/ \
            -e MCP_AUTH_AUDIENCE=dynamic-mcp \
            -e MCP_AUTH_REQUIRED_SCOPES=mcp.invoke \
            dynamic-mcp:test

      - name: Wait for readiness
        run: |
          for i in $(seq 1 30); do
            if curl -fsS http://127.0.0.1:8788/readyz >/dev/null; then
              exit 0
            fi
            sleep 2
          done
          echo "JWT-enabled container did not become ready in time."
          docker logs dynamic-mcp-http-jwt
          exit 1

      - name: Verify JWT protection and operational endpoints
        run: |
          no_auth_status="$(curl -sS -o /tmp/mcp-no-auth.json -w "%{http_code}" \
            -X POST http://127.0.0.1:8788/mcp \
            -H 'content-type: application/json' \
            --data '{}')"
          if [ "$no_auth_status" -ne 401 ]; then
            echo "Expected 401 for unauthenticated /mcp request, got: $no_auth_status"
            cat /tmp/mcp-no-auth.json || true
            exit 1
          fi

          auth_status="$(curl -sS -o /tmp/mcp-with-auth.json -w "%{http_code}" \
            -X POST http://127.0.0.1:8788/mcp \
            -H "Authorization: Bearer $JWT_TOKEN" \
            -H 'content-type: application/json' \
            --data '{}')"
          if [ "$auth_status" -eq 401 ] || [ "$auth_status" -eq 403 ]; then
            echo "Expected authenticated /mcp request to bypass auth rejection, got: $auth_status"
            cat /tmp/mcp-with-auth.json || true
            exit 1
          fi

          curl -fsS http://127.0.0.1:8788/livez >/dev/null
          curl -fsS http://127.0.0.1:8788/readyz >/dev/null
          curl -fsS http://127.0.0.1:8788/metrics >/dev/null

      - name: Show logs on failure
        if: failure()
        run: |
          docker logs dynamic-mcp-http-jwt || true
          docker logs dynamic-mcp-jwks || true

      - name: Cleanup
        if: always()
        run: |
          docker rm -f dynamic-mcp-http-jwt dynamic-mcp-jwks || true
          docker network rm dynamic-mcp-ci || true

  compose-postgres-smoke:
    runs-on: ubuntu-latest
    needs: verify

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate compose file
        run: docker compose -f deploy/docker-compose.postgres.yml config -q

      - name: Start compose stack
        run: docker compose -f deploy/docker-compose.postgres.yml up -d --build

      - name: Wait for stack readiness
        run: |
          for i in $(seq 1 40); do
            if curl -fsS http://127.0.0.1:8788/readyz >/dev/null; then
              exit 0
            fi
            sleep 3
          done
          echo "Compose stack did not become ready in time."
          docker compose -f deploy/docker-compose.postgres.yml logs
          exit 1

      - name: Probe liveness and readiness
        run: |
          curl -fsS http://127.0.0.1:8788/livez
          curl -fsS http://127.0.0.1:8788/readyz

      - name: Show compose logs on failure
        if: failure()
        run: docker compose -f deploy/docker-compose.postgres.yml logs

      - name: Teardown
        if: always()
        run: docker compose -f deploy/docker-compose.postgres.yml down -v --remove-orphans

  k8s-manifest-validate:
    runs-on: ubuntu-latest
    needs: verify

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate k8s manifests (kubeconform)
        run: |
          docker run --rm -v "$PWD":/work -w /work ghcr.io/yannh/kubeconform:latest \
            -strict \
            -summary \
            deploy/k8s/dynamic-mcp-postgres.yaml \
            deploy/k8s/dynamic-mcp-scalability.yaml \
            deploy/k8s/dynamic-mcp-networkpolicy.yaml
